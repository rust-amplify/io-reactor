// Library for concurrent I/O resource management using reactor pattern.
//
// SPDX-License-Identifier: Apache-2.0
//
// Written in 2021-2025 by
//     Dr. Maxim Orlovsky <orlovsky@ubideco.org>
//     Alexis Sellier <alexis@cloudhead.io>
//
// Copyright 2022-2025 UBIDECO Labs, InDCS, Lugano, Switzerland. All Rights reserved.
// Copyright 2021-2023 Alexis Sellier <alexis@cloudhead.io>. All Rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
// in compliance with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
// or implied. See the License for the specific language governing permissions and limitations under
// the License.

//! Implementation of a [`FileResource`] resource which can be used inside the I/O reactor.

use std::collections::VecDeque;
use std::fs::File;
use std::io::{self, Read, Seek, SeekFrom, Write};
use std::os::fd::{AsRawFd, RawFd};

use crate::poller::IoType;
use crate::{Io, Resource, WriteAtomic, WriteError};

#[allow(dead_code)]
const NAME: &str = "file";

/// I/O events generated by [`FileResource`].
pub enum FileEvent {
    /// New data read from file.
    Read(Vec<u8>),
    /// End of file reached.
    Eof,
    /// File has been closed due to an error.
    Closed(io::Error),
}

/// File resource usable in a reactor.
#[derive(Debug)]
pub struct FileResource {
    file: File,
    writable: bool,
    write_intent: bool,
    write_buffer: VecDeque<u8>,
    read_buffer: Vec<u8>,
}

impl AsRawFd for FileResource {
    fn as_raw_fd(&self) -> RawFd { self.file.as_raw_fd() }
}

impl Resource for FileResource {
    type Event = FileEvent;

    fn interests(&self) -> IoType {
        if self.writable && self.write_intent {
            IoType::read_write()
        } else {
            IoType::read_only()
        }
    }

    fn handle_io(&mut self, io: Io) -> Option<Self::Event> {
        match io {
            Io::Read => self.handle_readable(),
            Io::Write => self.handle_writeable(),
        }
    }
}

impl WriteAtomic for FileResource {
    fn is_ready_to_write(&self) -> bool { self.writable }

    fn empty_write_buf(&mut self) -> io::Result<bool> {
        let len = self.file.write(self.write_buffer.make_contiguous())?;
        self.write_buffer.drain(..len);
        if self.write_buf_len() > 0 {
            return Err(io::ErrorKind::WouldBlock.into());
        }
        Ok(len > 0)
    }

    fn write_or_buf(&mut self, buf: &[u8]) -> io::Result<()> {
        if buf.is_empty() {
            // Write empty data is a non-op
            return Ok(());
        }
        self.write_buffer.extend(buf);
        self.flush_buffer()
    }
}

impl Write for FileResource {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        match self.write_atomic(buf) {
            Ok(_) => Ok(buf.len()),
            Err(WriteError::NotReady) => Err(io::ErrorKind::NotConnected.into()),
            Err(WriteError::Io(err)) => Err(err),
        }
    }

    fn flush(&mut self) -> io::Result<()> { self.flush_buffer() }
}

// TODO: This is blocking, we need to handle it in some other way
impl Seek for FileResource {
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { self.file.seek(pos) }
}

/// Configuration for constructing [`FileResource`].
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub struct FileResourceConfig {
    /// Is file opened with a write access.
    pub writable: bool,
    /// Size for the write buffer.
    pub write_buf_len: usize,
    /// Size for the read buffer.
    pub read_buf_len: usize,
}

impl FileResourceConfig {
    /// Configuration for read-only file resource.
    pub const fn read_only() -> Self {
        Self {
            writable: false,
            write_buf_len: 1024,
            read_buf_len: 1024,
        }
    }

    /// Configuration for read-write file resource.
    pub const fn read_write() -> Self {
        let mut me = Self::read_only();
        me.writable = true;
        me
    }

    /// Adjusted configuration changing read buffer length.
    pub const fn set_read_buf_len(mut self, len: usize) -> Self {
        self.read_buf_len = len;
        self
    }

    /// Adjusted configuration changing write buffer length.
    pub const fn set_write_buf_len(mut self, len: usize) -> Self {
        debug_assert!(
            self.writable,
            "adjusting size of a write buffer for read-only file doesn't make sense"
        );
        self.write_buf_len = len;
        self
    }
}

impl FileResource {
    /// Constructs file resource from a provided file and given configuration
    pub fn new(file: File, conf: FileResourceConfig) -> Self {
        Self {
            file,
            writable: conf.writable,
            write_intent: false,
            write_buffer: VecDeque::with_capacity(conf.write_buf_len),
            read_buffer: Vec::with_capacity(conf.read_buf_len),
        }
    }

    /// Provides human-readable string describing the file handle.
    pub fn display(&self) -> String { format!("fd={}", self.file.as_raw_fd()) }

    fn handle_readable(&mut self) -> Option<FileEvent> {
        match self.file.read(&mut self.read_buffer) {
            Ok(0) => Some(FileEvent::Eof),
            Ok(len) => Some(FileEvent::Read(self.read_buffer[..len].to_vec())),
            Err(err) if err.kind() == io::ErrorKind::WouldBlock => {
                // This shouldn't normally happen, since this function is only called
                // when there's data on the socket. We leave it here in case external
                // conditions change.
                #[cfg(feature = "log")]
                log::warn!(target: NAME,
                    "WOULD_BLOCK on resource which had read intent - probably normal thing to happen"
                );
                None
            }
            Err(err) => Some(self.terminate(err)),
        }
    }

    fn handle_writeable(&mut self) -> Option<FileEvent> {
        match self.flush() {
            Ok(_) => None,
            // In this case, write couldn't complete. Leave `needs_flush` set to be notified when
            // the socket is ready to write again.
            Err(err)
                if [
                    io::ErrorKind::WouldBlock,
                    io::ErrorKind::WriteZero,
                    io::ErrorKind::OutOfMemory,
                    io::ErrorKind::Interrupted,
                ]
                .contains(&err.kind()) =>
            {
                #[cfg(feature = "log")]
                log::warn!(target: NAME, "Resource {} was not able to consume any data even though it has announced its write readiness", self.display());
                self.write_intent = true;
                None
            }
            Err(err) => Some(self.terminate(err)),
        }
    }

    /// Returns the length of the read buffer.
    pub fn read_buf_len(&self) -> usize { self.read_buffer.len() }

    /// Returns the length of the write buffer.
    pub fn write_buf_len(&self) -> usize { self.write_buffer.len() }

    fn flush_buffer(&mut self) -> io::Result<()> {
        let orig_len = self.write_buffer.len();
        #[cfg(feature = "log")]
        log::trace!(target: NAME, "Resource {} is flushing its buffer of {orig_len} bytes", self.display());
        let len =
            self.file.write(self.write_buffer.make_contiguous()).or_else(|err| {
                match err.kind() {
                    io::ErrorKind::WouldBlock
                    | io::ErrorKind::OutOfMemory
                    | io::ErrorKind::WriteZero
                    | io::ErrorKind::Interrupted => {
                        #[cfg(feature = "log")]
                        log::warn!(target: NAME, "Resource {} kernel buffer is fulled (system message is '{err}')", self.display());
                        Ok(0)
                    },
                    _ => {
                        #[cfg(feature = "log")]
                        log::error!(target: NAME, "Resource {} failed write operation with message '{err}'", self.display());
                        Err(err)
                    },
                }
            })?;
        if orig_len > len {
            #[cfg(feature = "log")]
            log::debug!(target: NAME, "Resource {} was able to consume only a part of the buffered data ({len} of {orig_len} bytes)", self.display());
            self.write_intent = true;
        } else {
            #[cfg(feature = "log")]
            log::trace!(target: NAME, "Resource {} was able to consume all the buffered data ({len} of {orig_len} bytes)", self.display());
            self.write_intent = false;
        }
        self.write_buffer.drain(..len);
        Ok(())
    }

    fn terminate(&mut self, reason: io::Error) -> FileEvent {
        #[cfg(feature = "log")]
        log::trace!(target: NAME, "Terminating session {} due to {reason:?}", self.display());

        FileEvent::Closed(reason)
    }
}
